{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/docker-compose",
    "result": {"data":{"markdownRemark":{"html":"<p>This may be one of the most useful features you learn about Docker. We've been mixing various different facets of deploying your app to production and creating development environments. This feature in particular is geared much more for development environments. Many times when you're developing containers you're not in just a single container environment (though that does happen too.) When this happens, you need to coordinate multiple containers when you're doing local dev and you've seen in the previous chapter, networking, that it's possible if a bit annoying.</p>\n<p>With Docker Compose we simplify this a lot. Docker Compose allows us the ability to coordinate multiple containers and do so with one YAML file. This is great if you're developing a Node.js app and it requires a database, caching, or even if you have two+ separate apps in two+ separate containers that depend on each other or all the above! Docker Compose makes it really simple to define the relationship between these containers and get them all running with one <code class=\"language-text\">docker-compose up</code>.</p>\n<p>Do note that Docker does say that Docker Compose is suitable for production environments if you have a single instance running multiple containers. This is atypical for the most part: if you have multiple containers, typically you want the ability to have many instances.</p>\n<p>In addition to working very well dev, Docker Compose is very useful in CI/CD scenarios when you want GitHub Actions or some CI/CD provider to spin up multiple environments to quickly run some tests.</p>\n<p>Okay so let's get our previous app working: the one with a MongoDB database being connected to by a Node.js app. Create a new file in the root directory of your project called <code class=\"language-text\">docker-compose.yml</code> and put this in there:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"3000:3000\"</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> .<span class=\"token punctuation\">:</span>/home/node/code\n      <span class=\"token punctuation\">-</span> /home/node/code/node_modules\n    <span class=\"token key atrule\">links</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> db\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_CONNECTION_STRING</span><span class=\"token punctuation\">:</span> mongodb<span class=\"token punctuation\">:</span>//db<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n  <span class=\"token key atrule\">db</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo<span class=\"token punctuation\">:</span><span class=\"token number\">3</span></code></pre></div>\n<p>This should feel familiar even if it's new to you. This is basically all of the CLI configurations we were giving to the two containers but captured in a YAML file. The version is which version of the Docker Compose YAML you're using. They do this so they can stay backwards compatible and still add new features. As of writing, v3 is the latest.</p>\n<p>In <code class=\"language-text\">service</code> we define the containers we need for this particular app. We have two: the <code class=\"language-text\">web</code> container (which is our app) and the <code class=\"language-text\">db</code> container which is MongoDB. We then identify where the Dockerfile is with <code class=\"language-text\">build</code>, which ports to expose in <code class=\"language-text\">ports</code>, which volumes to make in <code class=\"language-text\">volumes</code> (here we're mounting in our code so that we can keep code without having to rebuild the image), and the <code class=\"language-text\">environment</code> variables using that field.</p>\n<p>Notice the second <code class=\"language-text\">volumes</code> entry. We do this so that the <code class=\"language-text\">node_modules</code> from the original build container get mounted in, not the ones on your local host. We do this because it's important to have node_modules that built for the system they're running on. If you run <code class=\"language-text\">npm install</code> on a Windows machine and then copy those to a Ubuntu machine, chances are that they'll break due to how <code class=\"language-text\">node_modules</code> can build native depenencies. If you <code class=\"language-text\">npm install</code> something on your app, you may be to stop the app and run <code class=\"language-text\">docker-compose build</code> again.</p>\n<p>The one interesting one here is the <code class=\"language-text\">links</code> field. In this one we're saying that the <code class=\"language-text\">web</code> container needs to be connected to the <code class=\"language-text\">db</code> container. This means Docker will start this container first and then network it to the <code class=\"language-text\">web</code> container. This works the same way as what we were doing in the previous lesson.</p>\n<p>The <code class=\"language-text\">db</code> container is pretty simple: it's just the <code class=\"language-text\">mongo</code> container from Docker Hub. This is actually smart enough to expose 27017 as the port and to make a volume to keep the data around between restarts so we don't actually have to do anything for that. If you needed any other containers, you'd just put them here in services.</p>\n<p>There's a lot more to compose files than what I've shown you here but I'll let you explore that on your own time. <a href=\"https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples\">Click here</a> to see the docs to see what else is possible.</p>\n<p>This will start and work now, just run <code class=\"language-text\">docker-compose up</code> and it'll get going. I just want to do one thing: let's make our app even more productive to develop on. Go to your Dockerfile for the app make it read a such:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm i -g nodemon</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">USER</span> node</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> mkdir /home/node/code</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /home/node/code</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--chown</span><span class=\"token punctuation\">=</span><span class=\"token string\">node:node</span></span> package-lock.json package.json ./</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--chown</span><span class=\"token punctuation\">=</span><span class=\"token string\">node:node</span></span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"nodemon\"</span>, <span class=\"token string\">\"index.js\"</span>]</span></code></pre></div>\n<p>Now we can write our code and every time it save it'll restart the server from within the container. This will make this super productive to work with!</p>\n<p>While we're about to get to Kubernetes which will handle bigger deployment scenarios than Docker Compose can, you can use <code class=\"language-text\">docker-compose up --scale web=10</code> to scale up your web container to 10 concurrently running containers. This won't work at the moment because they're all trying to listen on the host on port 3000 but we could use something like NGINX or HAProxy to loadbalance amongst the containers. It's a bit more advance use case and less useful for Compose since at that point you should probably just use Kubernetes or something similar. We'll approach it in the Kubernetes chapter.</p>","frontmatter":{"path":"/docker-compose","title":"Docker Compose","order":7,"section":"Multi Container Projects","description":"Docker Compose allows for setting up multiple container set ups with a single configuration file as opposed to having to hand create your development. Brian shows how to take the Node.js + MongoDB app and create the environment with just `docker-compose up`."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":9,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}