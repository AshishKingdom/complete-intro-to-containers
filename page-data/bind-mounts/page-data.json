{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/bind-mounts",
    "result": {"data":{"markdownRemark":{"html":"<p>So far we've been dealing with self-contained containers. Normally this is all you ever want: containers that can spin up and spin down as frequently as they need to. They're ephemeral, temporary, and disposable. None of these containers are \"snowflakes\". When I say snowflakes, picture you're running a server that's serving a Wordpress site. Imagine setting up this server, SSH'ing into the server, and setting everything up to be just right and tuned to the exact way you need it. This would be a snowflake server: if someone goes and deletes this server, you're screwed. You have to go and spend a bunch of time re-setting up this server. This is exactly the sort of thing we're trying to avoid with containers. We want to make our servers easy to reproduce whenever we want so we can spin up and spin down servers at will.</p>\n<p>However not everything can fit neatly into a container all the time. Sometimes our containers need to be stateful in some capacity. Sometimes our containers need to read and write to the host. This is fundamentally at odds with the idea of a stateless, able-to-create-and-destroy-anytime container that we've been adhering to thusfar. So what are we to do?</p>\n<p>Enter volumes and bind mounts. Both of these are methods of reading and writing to the host but with slight-but-important differences of when to use which. We'll go over both.</p>\n<h2 id=\"bind-mounts\" style=\"position:relative;\"><a href=\"#bind-mounts\" aria-label=\"bind mounts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bind Mounts</h2>\n<p>Let's start here because this is easier to see the use case for. Bind mounts allow you to mount files from your host computer into your container. This allows you to use the containers a much more flexible way than previously possible: you don't have to know what files the container will have <em>when you build it</em> and it allows you to determine those files <em>when you run it</em>.</p>\n<p>Let's go over an example of how this could be useful.</p>\n<p>In the previous project, we used the NGINX container to build a container with our static assets baked into the container. In general this what I recommend you do since now we can ship that container anywhere and it'll just work. It's totally self-contained. But what if we just want to run a NGINX container locally to test stuff out? Sure, we could make a new Dockerfile and write it, but wouldn't it be cool if we could just use the NGINX container directly? We can! Let's try it. Go back to your static site project from the previous lesson. Let's use the <code class=\"language-text\">nginx</code> container to serve directly from it.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># from the root directory of your CRA app</span>\n<span class=\"token function\">docker</span> run --mount <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span>bind,source<span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>\"</span>/build,target<span class=\"token operator\">=</span>/usr/share/nginx/html -p <span class=\"token number\">8080</span>:80 nginx</code></pre></div>\n<p>This is how you do bind mounts. It's a bit verbose but necessary. Let's dissect it.</p>\n<ul>\n<li>We use the <code class=\"language-text\">--mount</code> flag to identify we're going to be mounting something in from the host.</li>\n<li>As far as I know the only two types are <code class=\"language-text\">bind</code> and <code class=\"language-text\">volume</code>. Here we're using bind because we to mount in some piece of already existing data from the host.</li>\n<li>In the source, we identify what part of the host we want to make readable-and-writable to the container. It has to be an absolute path (e.g we can't say <code class=\"language-text\">\"./build\"</code>) which is why use the <code class=\"language-text\">\"$(pwd)\"</code> to get the <strong>p</strong>resent <strong>w</strong>orking <strong>d</strong>irectory to make it an absolute path.</li>\n<li>The target is where we want those files to be mounted in the container. Here we're putting it in the spot that NGINX is expecting.</li>\n<li>As a side note, you can mount as many mounts as you care to, and you mix bind and volume mounts. NGINX has a default config that we're using but if we used another bind mount to mount an NGINX config to <code class=\"language-text\">/etc/nginx/nginx.conf</code> it would use that instead.</li>\n</ul>\n<p>Again, it's preferable to bake your own container so you don't have to ship the container and the code separately; you'd rather just ship one thing that you can run without much ritual nor ceremony. But this is a useful trick to have in your pocket.</p>","frontmatter":{"path":"/bind-mounts","title":"Bind Mounts","order":6,"section":"Features in Docker","description":"Let's start here because this is easier to see the use case for. Bind mounts allow you to mount files from your host computer into your container. This allows you to use the containers a much more flexible way than previously possible."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":9,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}