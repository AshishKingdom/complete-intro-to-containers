{
    "componentChunkName": "component---src-templates-lesson-template-js",
    "path": "/chroot",
    "result": {"data":{"markdownRemark":{"html":"<h2 id=\"chroot\" style=\"position:relative;\"><a href=\"#chroot\" aria-label=\"chroot permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>chroot</h2>\n<p>I've heard people call this \"cha-root\" and \"change root\". I'm going to stick to \"change root\" because I feel less ridiculous saying that. It's a Linux command that allows you to set the root directory of a new process. In our container use case, we just set the root directory to be where-ever the new container's new root directory should be. And now the new container group of processes can't see anything outside of it, eliminating our security problem because the new process has no visibility outside of its new root.</p>\n<p>Let's try it. Start up a Ubuntu VM however you feel most comfortable. I'll be using Docker (and doing containers within containers ü§Ø). If you're like me, run <code class=\"language-text\">docker run -it --name docker-host --rm --privileged ubuntu:bionic</code>. This will download the <a href=\"https://hub.docker.com/_/ubuntu\">official Ubuntu container</a> from Docker Hub and grab the version marked with the <em>bionic</em> tag. In this case, <em>latest</em> means it's the latest stable release (18.04.) You could put <code class=\"language-text\">ubuntu:devel</code> to get the latest development of Ubuntu (as of writing that'd be 19.10). <code class=\"language-text\">docker run</code> means we're going to run some commands in the container, and the <code class=\"language-text\">-it</code> means we want to make the shell interactive (so we can use it like a normal terminal.)</p>\n<p>If you're in Windows and using WSL, just open a new WSL terminal in Ubuntu. ‚úåÔ∏è</p>\n<p>To see what version of Ubuntu you're using, run <code class=\"language-text\">cat /etc/issue/</code>. <code class=\"language-text\">cat</code> reads a file and dumps it into the output which means we can read it, and <code class=\"language-text\">/etc/issue</code> is a file that will tell us what distro we're using. Mine says <code class=\"language-text\">Ubuntu 18.04.3 LTS \\n \\l</code>.</p>\n<p>Okay, so let's attempt to use <code class=\"language-text\">chroot</code> right now.</p>\n<ol>\n<li>Make a new folder in your home directory via <code class=\"language-text\">mkdir /my-new-root</code>.</li>\n<li>Inside that new folder, run <code class=\"language-text\">echo \"my super secret thing\" >> /my-new-root/secret.txt</code>.</li>\n<li>Now try to run <code class=\"language-text\">chroot /my-new-root bash</code> and see the error it gives you.</li>\n</ol>\n<p>You should see something about failing to run a shell or not being able to find bash. That's because bash is a program and your new root wouldn't have bash to run (because it can't reach outside of its new root.) So let's fix that! Run:</p>\n<ol>\n<li><code class=\"language-text\">mkdir /my-new-root/bin</code></li>\n<li><code class=\"language-text\">cp /bin/bash /bin/ls /my-new-root/bin/</code></li>\n<li><code class=\"language-text\">chroot /my-new-root bash</code></li>\n</ol>\n<p>Still not working! The problem is that these commands rely on libraries to power them and we didn't bring those with us. So let's do that too. Run <code class=\"language-text\">ldd /bin/bash</code>. This print out something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ ldd /bin/bash\n  linux-vdso.so.1 <span class=\"token punctuation\">(</span>0x00007fffa89d8000<span class=\"token punctuation\">)</span>\n  libtinfo.so.5 <span class=\"token operator\">=</span><span class=\"token operator\">></span> /lib/x86_64-linux-gnu/libtinfo.so.5 <span class=\"token punctuation\">(</span>0x00007f6fb8a07000<span class=\"token punctuation\">)</span>\n  libdl.so.2 <span class=\"token operator\">=</span><span class=\"token operator\">></span> /lib/x86_64-linux-gnu/libdl.so.2 <span class=\"token punctuation\">(</span>0x00007f6fb8803000<span class=\"token punctuation\">)</span>\n  libc.so.6 <span class=\"token operator\">=</span><span class=\"token operator\">></span> /lib/x86_64-linux-gnu/libc.so.6 <span class=\"token punctuation\">(</span>0x00007f6fb8412000<span class=\"token punctuation\">)</span>\n  /lib64/ld-linux-x86-64.so.2 <span class=\"token punctuation\">(</span>0x00007f6fb8f4b000<span class=\"token punctuation\">)</span></code></pre></div>\n<p>These are the libraries we need for bash. Let's go ahead and copy those into our new environment.</p>\n<ol>\n<li><code class=\"language-text\">mkdir /my-new-root/lib /my-new-root/lib64</code> or you can do <code class=\"language-text\">/my-new-root/lib{,64}</code> if you want to be fancy</li>\n<li>Then we need to copy all those paths (ignore the lines that don't have paths) into our directory. Make sure you get the right files in the right directory. In my case above (yours likely will be different) it'd be two commands:\n<ol>\n<li><code class=\"language-text\">cp /lib/x86_64-linux-gnu/libtinfo.so.5 /lib/x86_64-linux-gnu/libdl.so.2 /lib/x86_64-linux-gnu/libc.so.6 /my-new-root/lib</code></li>\n<li><code class=\"language-text\">cp /lib64/ld-linux-x86-64.so.2 /my-new-root/lib64</code></li>\n</ol>\n</li>\n<li>Do it again for <code class=\"language-text\">ls</code>. Run <code class=\"language-text\">ldd /bin/ls</code></li>\n<li>Follow the same process to copy the libraries for <code class=\"language-text\">ls</code> into our <code class=\"language-text\">my-new-root</code>.\n<ol>\n<li><code class=\"language-text\">cp /lib/x86_64-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libpcre.so.3 /lib/x86_64-linux-gnu/libpthread.so.0 /my-new-root/lib</code></li>\n</ol>\n</li>\n</ol>\n<p>Now, finally, run <code class=\"language-text\">chroot /my-new-root bash</code> and run <code class=\"language-text\">ls</code>. You should successfully see everything in the directory. Now try <code class=\"language-text\">pwd</code> to see your working directory. You should see <code class=\"language-text\">/</code>. You can't get out of here! This, before being called containers, was called a jail for this reason. At any time, hit CTRL+D or run <code class=\"language-text\">exit</code> to get out of your chrooted environment.</p>\n<h2 id=\"cat-exercise\" style=\"position:relative;\"><a href=\"#cat-exercise\" aria-label=\"cat exercise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cat exercise</h2>\n<p>Now try running <code class=\"language-text\">cat secret.txt</code>. Oh no! Your new chroot-ed environment doesn't know how to cat! As an exercise, go make <code class=\"language-text\">cat</code> work the same way we did above!</p>\n<p>Congrats you just cha-rooted the **** out of your first environment!</p>","frontmatter":{"path":"/chroot","title":"chroot","order":2.1,"section":"Crafting Containers By Hand","description":"chroot is the first of the important Linux kernel features that allow us to create contained processes without a whole virtualization layer. Brian shows how to use chroot to restrict a process to a certain file tree."}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":1,"path":"/intro","title":"Introduction"}}},{"node":{"frontmatter":{"order":2,"path":"/what-are-containers","title":"What Are Containers?"}}},{"node":{"frontmatter":{"order":2.1,"path":"/chroot","title":"chroot"}}},{"node":{"frontmatter":{"order":2.2,"path":"/namespaces","title":"Namespaces"}}},{"node":{"frontmatter":{"order":2.3,"path":"/cgroups","title":"cgroups"}}},{"node":{"frontmatter":{"order":3,"path":"/getting-set-up-with-docker","title":"Getting Set Up with Docker"}}},{"node":{"frontmatter":{"order":3.1,"path":"/docker-images-without-docker","title":"Docker Images without Docker"}}},{"node":{"frontmatter":{"order":3.2,"path":"/docker-images-with-docker","title":"Docker Images with Docker"}}},{"node":{"frontmatter":{"order":3.3,"path":"/nodejs-on-docker","title":"Node.js on Docker"}}},{"node":{"frontmatter":{"order":3.4,"path":"/tags","title":"Tags"}}},{"node":{"frontmatter":{"order":3.5,"path":"/docker-cli","title":"Docker CLI"}}},{"node":{"frontmatter":{"order":4,"path":"/dockerfile","title":"Intro to Dockerfiles"}}},{"node":{"frontmatter":{"order":4.1,"path":"/build-a-nodejs-app","title":"Build a Node.js App"}}},{"node":{"frontmatter":{"order":4.2,"path":"/more-complicated-nodejs-app","title":"A More Complicated Node.js App"}}},{"node":{"frontmatter":{"order":4.4,"path":"/expose","title":"A Note on EXPOSE"}}},{"node":{"frontmatter":{"order":4.5,"path":"/layers","title":"Layers"}}},{"node":{"frontmatter":{"order":5,"path":"/alpine-linux","title":"Alpine Linux"}}},{"node":{"frontmatter":{"order":5.1,"path":"/making-our-own-alpine-nodejs-container","title":"Making Our Own Alpine Node.js Container"}}},{"node":{"frontmatter":{"order":5.2,"path":"/multi-stage-builds","title":"Multi Stage Builds"}}},{"node":{"frontmatter":{"order":5.3,"path":"/static-assets-project","title":"Static Assets Project"}}},{"node":{"frontmatter":{"order":6,"path":"/bind-mounts","title":"Bind Mounts"}}},{"node":{"frontmatter":{"order":6.1,"path":"/volumes","title":"Volumes"}}},{"node":{"frontmatter":{"order":6.2,"path":"/dev-containers","title":"Using Containers for your Dev Environment"}}},{"node":{"frontmatter":{"order":6.3,"path":"/visual-studio-code","title":"Dev Containers with Visual Studio Code"}}},{"node":{"frontmatter":{"order":6.4,"path":"/networking","title":"Networking with Docker"}}},{"node":{"frontmatter":{"order":7,"path":"/docker-compose","title":"Docker Compose"}}},{"node":{"frontmatter":{"order":7.1,"path":"/kubernetes","title":"Kubernetes"}}},{"node":{"frontmatter":{"order":7.2,"path":"/kompose","title":"Kompose"}}},{"node":{"frontmatter":{"order":8,"path":"/buildah","title":"Buildah"}}},{"node":{"frontmatter":{"order":8.1,"path":"/podman","title":"Podman"}}},{"node":{"frontmatter":{"order":9,"path":"/conclusion","title":"Conclusion"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2959687377"]}